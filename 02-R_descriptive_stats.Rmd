# R and Descriptive Statistics - a primer


## R Programming language primer

### R objects

The R programming language comprises 6 major types of [R objects](https://rstudio-education.github.io/hopr/r-objects.html)

  - [Vectors](https://rstudio-education.github.io/hopr/r-objects.html#atomic-vectors)
  - [Matrix](https://rstudio-education.github.io/hopr/r-objects.html#matrices)
  - [Data Frame](https://rstudio-education.github.io/hopr/r-objects.html#data-frames)
  - [Lists](https://rstudio-education.github.io/hopr/r-objects.html#lists)
  - [Array](https://rstudio-education.github.io/hopr/r-objects.html#arrays)
  - [Factors](https://rstudio-education.github.io/hopr/r-objects.html#factors)



__Vectors__

______________

```{r eval=FALSE}
x <- c(1, 2, 3, 4, 5, 6)
# 1 2 3 4 5 6
x <- 1:6
# 1 2 3 4 5 6
x[1]
# 1
text <- c("Hello",  "World")
#  "Hello"  "World"
names(x) <- paste("name", 1:6, sep="")
# name1 name2 name3 name4 name5 name6 
#     1     2     3     4     5     6 

```

__Factors__

______________
```{r eval=FALSE}
subtype <- factor(c("Classical", "Basal", "Basal", "Classical"))
subtype
# [1] Classical Basal     Basal     Classical
# Levels: Basal Classical
```

__Matrix__

______________

```{r eval=FALSE}

m <- matrix(x, nrow = 2)
m
#      [,1] [,2] [,3]
# [1,]    1    3    5
# [2,]    2    4    6
m <- matrix(x, nrow = 2, byrow = TRUE)
m
#      [,1] [,2] [,3]
# [1,]    1    2    3
# [2,]    4    5    6

```

__Data Frame__

______________

```{r eval=FALSE}

df <- data.frame(cancerType = c("PDAC", "PDAC", "PDAC"),  
  KRAS_status = c("wt", "mut", "mut"), Subtype = c("Classical", "Classical", "Subtype"))
df
#   cancerType KRAS_status   Subtype
# 1       PDAC          wt Classical
# 2       PDAC         mut Classical
# 3       PDAC         mut   Subtype

```

__List__

______________

```{r eval=FALSE}
list1 <- list(1:20, "KRAS", list(1:6, 7:10))
list1
# [[1]]
#  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
# 
# [[2]]
# [1] "KRAS"
# 
# [[3]]
# [[3]][[1]]
# [1] 1 2 3 4 5 6
# 
# [[3]][[2]]
# [1]  7  8  9 10
```


__Array__

______________

```{r eval=FALSE}
ar <- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3))
ar
# , , 1
#
#      [,1] [,2]
# [1,]   11   13
# [2,]   12   14
#
# , , 2
#
#      [,1] [,2]
# [1,]   21   23
# [2,]   22   24
#
# , , 3
#
#      [,1] [,2]
# [1,]   31   33
# [2,]   32   34
```


### Loading Data



## Descriptive statistics and plotting


### The Cancer Gene Atlas (TCGA) - Pancreatic Ductal Adenocarcinoma Data Set

To develop a basic understanding of descriptive statistics and plotting we will use data described in [Integrated Genomic Characterization of Pancreatic Ductal Adenocarcinoma. Cancer Cell. 2017;32(2):185-203.e13. doi:10.1016/j.ccell.2017.07.007](https://www.cell.com/cancer-cell/fulltext/S1535-6108(17)30299-4).



The first step of course is to obtain the relevant data. We are primarily interested in:

   - Gene expression data
   - Clinical data - that comprises subtype designations

The Bioconductor package [TCGAbiolinks](https://bioconductor.org/packages/release/bioc/html/TCGAbiolinks.html) provides easy to use functions for downloading and analysing data published by The Cancer Genome Atlas (TCGA). A list of TCGA publications can be found here [https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga/publications](https://www.cancer.gov/about-nci/organization/ccg/research/structural-genomics/tcga/publications).

Vignettes describing the TCGAbiolinks package can be found using `browseVignettes(TCGAbiolinks)`

The first step of any analysis is to define libraries that we want to use:

```{r warning=FALSE, message=FALSE}

library(TCGAbiolinks)
library(SummarizedExperiment)
library(DT)

```

The following code segment downloads normalized expression data generated by the TCGA-PAAD project and returns a `RangedSummarizedExperiment` object which we have assigned the name `paad`.

```{r eval=FALSE}

query.exp.hg19 <- GDCquery(project = "TCGA-PAAD",
                  data.category = "Gene expression",
                  data.type = "Gene expression quantification",
                  platform = "Illumina HiSeq", 
                  file.type  = "normalized_results",
                  experimental.strategy = "RNA-Seq",
                  legacy = TRUE)
GDCdownload(query.exp.hg19)
paad <- GDCprepare(query.exp.hg19)

```


```{r echo=FALSE}
paad <- readRDS("RNASeqData/TCGA_paad.Rda")
```

The `paad` object is of class `RangedSummarizedExperiment` which comprises expression data, clinical data and information about the study in which the data was generated.    

```{r}
paad
```


Data within the `RangedSummarizedExperiment` object can be obtained using a number of built-in helper functions which we can identify using the `slotNames` function.

```{r}
slotNames(paad)
```

<br>

__Gene expression data__

__________________________


To access the expression data we use the `assay()$normalized_count` function:

```{r}
normalisedCounts <- assays(paad)$normalized_count
datatable(head(normalisedCounts))
```


<br>


Let's explore `normalisedCounts`

```{r}
class(normalisedCounts)
dim(normalisedCounts)
```

We can see that `normalisedCounts` is of class `matrix` and has 19947 rows (representing genes) and 183 columns (representing the patient samples).


We can extract the expression levels of GATA6 from normaliseCounts using the following notation [<rows>, <columns>]:

```{r}
head(normalisedCounts["GATA6", ])
```





<br>


__Clinical data__

__________________________

To access the clinical data we can use the `colData()` function:

```{r}
colData(paad)[1:5, 1:5]
```


```{r}
 colnames(colData(paad))[1:20]
```


__PDAC Subtypes__

___________________________


We are interested in obtaining Subtype specific information. The `paad` object comprises Subtype information for the Collisson, Moffitt and Bailey Classification schemes under the following columns:


```
#colnames(colData(paad))[grep("subtype_mRNA", colnames(colData(paad)))]

[1] "subtype_mRNA.Moffitt.clusters..76.High.Purity.Samples.Only...1basal..2classical"         "subtype_mRNA.Moffitt.clusters..All.150.Samples..1basal..2classical"                     
[3] "subtype_mRNA.Collisson.clusters..All.150.Samples..1classical.2exocrine.3QM"              "subtype_mRNA.Bailey.Clusters..All.150.Samples..1squamous.2immunogenic.3progenitor.4ADEX"
```

Let's extract the subtype information for the Moffitt classification scheme:

```{r}
subtype <- colData(paad)[,"subtype_mRNA.Moffitt.clusters..All.150.Samples..1basal..2classical"]
subtype
```


We want to compare the expression of a specific gene between the Classical and Basal samples. Looking at the 'subtype' vector that we have just created there are multiple samples that do not have a Moffitt subtype - designated by `NA`. We need to remove these! 

```{r}
expFinal <- normalisedCounts[,!is.na(subtype)]
subtypeFinal <- subtype[!is.na(subtype)]
subtypeFinal[subtypeFinal == 1] <- "Basal"
subtypeFinal[subtypeFinal == 2] <- "Classical"
```


### Boxplots


A common task that we are asked to perform is to determine whether a given gene is enriched in a specific subtype of PDAC.

How do we go about performing such a task?

```{r}

expData <- data.frame(samplename=colnames(expFinal), GATA6=expFinal["GATA6",], HNF4A=expFinal["HNF4A",], EGFR=expFinal["EGFR",], KRT17=expFinal["KRT17",], Subtype=subtypeFinal)

```



```{r}
library(ggpubr)

# GATA6
ggboxplot(expData, x = "Subtype", y = "GATA6",
          title = "GATA6 Expression by Subtype", ylab = "Expression",
          color = "Subtype", palette = "jco")

```
```{r}

ggboxplot(expData, x = "Subtype", y = c("GATA6","HNF4A"),
          title = "Expression by Subtype", 
          combine = TRUE,
          ylab = "Expression",
          color = "Subtype", palette = "jco")


```


```{r}
gghistogram(expData,
       x = c("GATA6","HNF4A"),
       y = "..density..",
       combine = TRUE,                  # Combine the 3 plots
       xlab = "Expression", 
       add = "median",                  # Add median line. 
       rug = TRUE,                      # Add marginal rug
       color = "Subtype", 
       fill = "Subtype",
       palette = "jco"
)
```






```{r}
my_comparisons <- list(c("Basal", "Classical"))

ggboxplot(expData, x = "Subtype", y = c("GATA6","HNF4A"),
          title = "Expression by Subtype", 
          combine = TRUE,
          ylab = "Expression",
          color = "Subtype", palette = "jco") +
  stat_compare_means(comparisons = my_comparisons)
```
```{r}
my_comparisons <- list(c("Basal", "Classical"))

ggboxplot(expData, x = "Subtype", y ="KRT17",
          title = "KRT17 Expression by Subtype", 
          ylab = "Expression",
          color = "Subtype", palette = "jco") +
  stat_compare_means(comparisons = my_comparisons)
```



```{r warning=FALSE, message=FALSE}
compare_means(KRT17 ~ Subtype, data=expData)
```


```{block2, course_reminder, type='rmdnote'}
**TASK: Repeat the above analysis using the Bailey classification scheme**
```


### Clustering

Clustering is a common analysis performed for gene expression data. The most often performed clustering method is hierarchical clustering which typically takes the form of a heatmap.

As an example, we will apply hierarchical clustering to the selection of genes provided in Moffitt et al

We will first compute the Pearson correlation between the genes. Note that we must operate on the transpose of the matrix because the R function `cor()` operates on the columns. 

```{ r }
genes.cor <- cor(t(expFinal), use="pairwise.complete.obs", method="pearson")
genes.cor[1:10,1:10]
```

The Pearson correlation coefficient is a similarity metric, values of which vary from -1 (perfect anticorrelation) to +1 (perfect correlation), see Lectures Chap.1. Pearson's correlation can be transformed into a distance metric by subtracting from 1. The Pearson distance would then vary from 0 (perfect correlation) to 2 (perfect anti-correlation). Hierarchical clustering of the Pearson distance metric can be achieved by the \texttt{hclust()} function. We will use the \texttt{"average"} linkage as an agglomeration rule. 


```{ r }
genes.cor.dist <- as.dist(1-genes.cor)
genes.tree <- hclust(genes.cor.dist, method='average')
plot(genes.tree, main="Gene clustering by Pearson distance and average linkage", xlab=NULL, 
     cex=0.1, cex.main=1.8)
```

